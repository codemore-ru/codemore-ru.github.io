---
layout: post
title: Ввод и вывод данных
author: Valentin Gubarev
section: programming
language: 'C/C++'
---

Возможности для ввода и вывода данных не являются частью языка Си. Необходимые для ввода и вывода данных функции имеются в стандартной библиотеке и специфицированы в заголовочном файле stdio.h.

Библиотечные функции ввода и вывода точно определяются стандартом ANSI, таким образом, программы, которые при взаимодействии с системным окружением не выходят за рамки возможностей стандартной библиотеки являются кроссплатформенными на уровне компиляции.

### Стандартный ввод и вывод

Текстовый поток состоит из последовательности строк. Каждая строка заканчивается символом новой строки.

Чтение одного символа из стандартного ввода (по умолчанию с клавиатуры) производится с помощью функции `getchar()`.

```int getchar();```

В качестве результата каждого своего вызова функция `getchar()` возвращает следующий символ ввода или, если обнаружен конец файла, константу `EOF` (End Of File). Именованная константа EOF определена в `stdio.h` и обычно равна -1, однако не следует в программе вместо EOF использовать -1.

Запись одного символа в стандартный вывод (по умолчанию экран) производится с помощью функции `putchar(int)`.

```int putchar(int);```

Вызов функции `putchar(symbol)` отправляет символ symbol в стандартный вывод (печатает на экране символ symbol) и возвращает значение symbol или, в случае ошибки, EOF.

Пример программы, получающей на входе последовательность различных символов и выводящей символы с кодом на единицу большую. Для окончания работы программы необходимо ввести пробел и нажать кнопку *Enter*. Код кнопки пробел - 0x20 (записан в шестнадцатеричной позиционной системе счисления). Вместо 0x20 можно было написать 32, а ещё лучше пробел выделенный апострофами - ' '.

{% highlight cpp linenos %}
#include <stdio.h>
int main() {
    int c;
    while( ( c = getchar() ), c != 0x20 ) {
        if(c > 0x20)
            putchar(c+1);
    }
    return 0;
}
{% endhighlight %}

При нажатии на кнопки клавиатуры на экране отображаются те же символы, которые нажаты на клавиатуре - это не действие вышеописанной программы, нажмите на Enter и только после этого Вы увидите работу программы.

Например, введите abcd123 и нажмите *Enter*, на экране, кроме надписи abcd123 должна появится надпись bcde234 (результат работы вышеуказанной программы). 

Пример программы, которая печатает только цифры.

{% highlight cpp linenos %}
#include <stdio.h>
int main() {
    int c;
    while( ( c = getchar() ), c != 0x20 ) {
        if('0' <= c && c <= '9')
            putchar(c);
    }
    return 0;
}
{% endhighlight %}

Например, введите a9b2c1 и нажмите *Enter*, на экране, кроме надписи a9b2c1 должна появится надпись 921 (результат работы вышеуказанной программы).

### Форматный вывод

Для организации форматного вывода может быть использована функция `printf()`.

```int printf(char *format, ...)```

Многоточие означает, что число и типы аргументов могут изменяться. Знак многоточие может стоять только в конце списка аргументов. Функция `printf()` возвращает количество записанных (напечатанных) символов.

Функция `printf()` использует свой первый аргумент (Си строку `format`), чтобы определить, сколько ещё ожидается аргументов и какого они будут типа.

Форматная строка содержит два вида объектов: обычные символы, которые копируются в выходной поток, и спецификации преобразования. Спецификации преобразования начинаются со знака % и заканчивается символом-спецификатором.

Между % и символом-спецификатором могут быть расположены (в указанном ниже порядке) следующие элементы:

* Знак минус, предписывающий выравнивать преобразованный аргумент по левому краю поля
* Число, предписывающее минимальную ширину поля
* Точка, отделяющая ширину поля от величины, устанавливающей точность
* Число (точность), специфицирующее максимальное количество печатаемых символов в строке, или количество цифр после десятичной точки - для чисел с плавающей запятой, или минимальное количество цифр - для целого
* Буква h, если печатаемое целое должно рассматриваться как short, или l, если целое должно рассматриваться как long
* Символ-спецификатор. Обязан быть, иначе поведение функции `printf()` не определено.

Символы спецификаторы:

*    `d` или `i` - Десятичное целое (`int`)
*    `o` - Беззнаковое восьмеричное целое (unsigned int)
*    `x` или `X` - Беззнаковое шестнадцатеричное целое (`unsigned int`)
*    `u` - Беззнаковое десятичное целое (`unsigned int`)
*    `c` - Одиночный символ (`int`)
*    `s` - Си строка. Печать символов до символа `\\0` (с кодом 0) и не более количества заданного точностью (`char *`)
*    `f` - Вещественное число [-]m.dddddd, где количество чисел после десятичной точки задаётся точностью (`double`)
*    `e` или `E` - Вещественное число [-]m.dddddde+-xx или [-]m.ddddddE+-xx, где количество чисел после десятичной точки задаётся точностью (double)
*    `g` или `G` - Вещественное число. Если порядок меньше точности, выводит как при спецификаторе `f`, в противном случае как при спецификаторе e или E (`double`)
*    `p` - Указатель, представление зависит от реализации (`void *`)
*    `%` - Печатается %

Ширину и точность можно специфицировать с помощью `*`, в этом случает величина берётся из следующего аргумента.

Шаблон спецификации преобразования.

```[-][минимальная ширина поля][.точность][h | l][Символ-спецификатор]```

Далее на каждой новой строке представлен пример, попробуйте определить, что будет выведено и проверьте правы ли Вы, набрав код и запустив программу на компьютере.
{% highlight cpp linenos %}
printf("%*.*f",8,3,12.123456789);
printf("\n%.*s",printf("%*.*f",8,3,12.123456789),"1234567890");
printf("\n%.*s",printf("%-*.*f",8,3,12.123456789),"1234567890");
printf("\n%10.*s",printf("%-*.*f",8,3,12.123456789),"1234567890");
printf("\n%-10.*s",printf("%-*.*f",8,3,12.123456789),"1234567890");
{% endhighlight %}

