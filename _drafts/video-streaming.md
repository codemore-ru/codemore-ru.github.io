---
layout: post
title: Потоковое воспроизведение видео в браузере с помощью FFmpeg
author: Alexey Nurgaliev
---

Иногда возникает необходимость воспроизведения в браузере видео-файлов. 
Использовать специальный видео-хостинг (вроде YouTube) не всегда есть возможность (например, если файлы загружены пользователями).

Самый простой способ добавить видео на страницу, это использовать тег `<video>`:

```html
<video src="/path/to/video.mp4">
```

В браузере уже есть стандартный встроенный видео-плеер, который проиграет переданный в параметре `src` файл.
У этого способа есть ряд проблем:

* Интерфейс плеера и его возможности различается между браузерами. Это можно решить, использовав какой-нибудь JavaScript-плеер, вроде [Video.js](https://videojs.com/).
* В общем случае пользователю нужно скачать весь файл и пока скачивание не закончится, перемотка работать не будет. 
  Частично это можно решить поддержкой [Range](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range)-запросов на сервере, так браузер сможет скачивать с сервера не весь файл, а только его фрагменты, которые необходимы в данный момент.
* Формат видео и аудио должен поддерживаться браузером. 
  Браузеры могут воспроизводить только ограниченное количество форматов и добавить поддержку нового не всегда возможно - в лучшем случае пользователю потребуется установить расширение. 
  Дополнительной проблемой будет то, что пересечение форматов, которые поддерживает большинство распространенных браузеров, невелико.
  Наверное сейчас (апрель 2021 года) наиболее оптимальным будет выбор [H.264](https://caniuse.com/mpeg4) для видео и [AAC](https://caniuse.com/aac) для аудио.
  Поэтому нужно либо ограничить возможность загрузки видео только указанными форматами, либо предварительно перекодировать файлы не сервере.
* Если файл большой, а у пользователя медленное соединение, то воспроизведение может постоянно прерываться на загрузку.
  Решением может быть подготовка нескольких файлов с разным битрейтом (а вместе с ним размером и качеством изображения), чтобы отдать пользователю наиболее подходящий скорости его соединения.
  Ни встроенный в браузер плеер, ни Video.js не позволяют каким-либо образом подбирать автоматически файл под скорость соединения, поэтому пользователю придется выбирать файл для воспроизведения самостоятельно. 

По таблице совместимости на caniuse можно заметить, что для аудио лучше подходит [MP3](https://caniuse.com/mp3) - у него немного более широкая поддержка в браузерах. 
Но на практике использовать MP3 вместе с DASH (об этом пойдет речь ниже) может быть проблематично - например Video.js ы некоторых случаях поддерживает воспроизведение только AAC.
{: .alert .alert-info}

Все перечисленные проблемы решает потоковое воспроизведение видео, если на стороне сервера файлы подготавливаются при помощи [FFmpeg](https://ffmpeg.org/), а на стороне браузера используется плеер Video.js.

FFmpeg - это набор программ и библиотек для работы с аудио и видео, поддерживающий большое количество форматов.
Здесь не будет описываться его установка, она зависит от используемой операционной системы, нужную информацию можно получить на официальном сайте.
{: .alert .alert-info}

## Потоковое воспроизведение видео в браузере

Для потокового воспроизведения (streaming, стриминга) видео в браузере в разное время использовались разные решения.
Раньше было популярно использование протоколов [RTSP](https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol)/[RTMP](https://en.wikipedia.org/wiki/Real-Time_Messaging_Protocol).
Встроенной их поддержки в браузерах не было (ее и сейчас нет), но существовали плееры на основе Flash. 
Сейчас использование Flash невозможно, поэтому RTSP/RTMP используются в основном для передачи видео между серверами, а в браузерах нужно использовать другие решения.

Специально для веба были разработаны протоколы передачи видео, использующие в качестве транспорта HTTP - стандартный протокол для всех браузеров.
Здесь можно выделить [HLS](https://en.wikipedia.org/wiki/HTTP_Live_Streaming), который разработан и поддерживается Apple, 
и [DASH](https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP), который разработан и поддерживается международной организацией MPEG.
Оба протокола зарегистрированы как стандарты:

* HLS зарегистрирован как стандарт IETF RFC 8216
* DASH зарегистрирован как стандарт ISO/IEC 23009-1:2019

Еще есть возможность передачи видео через [WebRTC](https://en.wikipedia.org/wiki/WebRTC), но это требует использования специального сервера для передачи данных (вроде [Kurento](https://www.kurento.org/)).

Далее будет рассматриваться использование протокола DASH - на практике он показался более гибким и удобным. 

## DASH и полное перекодирование

Формат DASH поддерживает использование видео с адаптивным битрейтом, т.е. выбор во время воспроизведения видео, наиболее подходящего скорости соединения или возможностям устройства пользователя.
Также поддерживается выбор из нескольких аудио-дорожек.

В общем случае, видео и аудио потоки разбиваются на отдельные файлы - сегменты фиксированной длины. 
При воспроизведении эти файлы просто скачиваются браузером, поэтому для размещения такого видео достаточно обычного HTTP-сервера.

FFmpeg поддерживает конвертирование видео в формат DASH, для этого можно воспользоваться примерно такой командой:  

```bash
ffmpeg -hide_banner -y -i input.mp4 \
       -r 25 -c:v libx264 -pix_fmt yuv420p -preset veryfast -profile:v main \
       -keyint_min 250 -g 250 -sc_threshold 0 \
       -c:a aac -b:a 128k -ac 2 -ar 44100 \
       -map v:0 -filter:v:0 "scale=-2:360"  -b:v:0 800k  -maxrate:0 856k  -bufsize:0 1200k \
       -map v:0 -filter:v:1 "scale=-2:432"  -b:v:1 1400k -maxrate:1 1498k -bufsize:1 2100k \
       -map v:0 -filter:v:2 "scale=-2:540"  -b:v:2 2000k -maxrate:2 2140k -bufsize:2 3500k \
       -map v:0 -filter:v:3 "scale=-2:720"  -b:v:3 2800k -maxrate:3 2996k -bufsize:3 4200k \
       -map v:0 -filter:v:4 "scale=-2:1080" -b:v:4 5000k -maxrate:4 5350k -bufsize:4 7500k \
       -map 0:a \
       -init_seg_name "init\$RepresentationID\$.\$ext\$" \
       -media_seg_name "chunk\$RepresentationID\$-\$Number%05d\$.\$ext\$" \
       -dash_segment_type mp4 \
       -use_template 1 \
       -use_timeline 0 \
       -seg_duration 10 \
       -adaptation_sets "id=0,streams=v id=1,streams=a" \
       -f dash \
       dash.mpd
```

Параметры здесь указаны следующие: 

* `-hide_banner` - не показывать информацию о сборке FFmpeg
* `-y` - перезаписать существующие файлы
* `-i input.mp4` - путь к входному файлу для перекодирования
* `-r 25` - частота кадров в секунду в перекодированном файле
* `-c:v libx264` - выбор кодека H.264 для кодирования видео
* `-pix_fmt yuv420p` - способ кодирования цвета (рекомендуется указать явно)
* `-preset veryfast` - настройки качества кодирования для кодека H.264, чем выше качество, тем ниже скорость кодирования.
  Можно выбрать из ряда `ultrafast,superfast,veryfast,faster,fast,medium,slow,slower,veryslow`.
  Обычно для веба скорость обработки важнее, поэтому рекомендуется выбирать более быстрые настройки.
* `-profile:v main` - настройка профиля для кодека H.264, `main` - безопасный вариант.
  Параметры кодека H.264 более подробно описаны в [документации FFmpeg](https://trac.ffmpeg.org/wiki/Encode/H.264). 
* `-keyint_min 250 -g 250 -sc_threshold 0` - настройка создания ключевых кадров. 
  Рекомендуется выбирать `keyint_min` и `g` близкими к длине сегмента, т.к. FFmpeg делит видео на сегменты как раз по ключевым кадрам.
  Так достигается наиболее точное разделение - сегменты получаются максимально близкими по длине.
  Если эти параметры не указать или выбрать другое значение, FFmpeg будет определять длину сегмента как ожидаемая продолжительность (seg_duration) плюс расстояние до следующего ключевого кадра.
  С учетом частоты кадров значение будет равно (частота_кадров х длина_сегмента), т.е. 25 х 10 = 250.
  `-sc_threshold 0` отключает встроенное в H.264 определение смены сцен и автоматическую расстановку ключевых кадров в них.
* `-c:a aac` - выбор кодека AAC для кодирования аудио
* `-b:a 128k` - битрейт аудио, обычно достаточно значения в пределах 100k-200k
* `-ac 2` - количество каналов аудио (1 - моно, 2 - стерео)  
* `-ar 44100` - частота дискретизации аудио, обычно выбирают 44100 или 48000
* `-map v:0 -filter:v:0 "scale=-2:360" -b:v:0 800k -maxrate:0 856k -bufsize:0 1200k` - параметры кодирования видео под определенный битрейт.
  Количество поддерживаемых настроек качества зависит от качества исходного видео и аппаратных возможностей по перекодированию - для каждой настройки видео нужно будет перекодировать полностью, поэтому не стоит добавлять очень много настроек.
  Выбор битрейта вопрос больше творческий и зависит от исходного видео, для примера можно воспользоваться [таблицей](https://docs.peer5.com/guides/production-ready-hls-vod/#how-to-choose-the-right-bitrate).
  * `-map v:0` - использовать видео №0 из входного файла
  * `-filter:v:0 "scale=-2:360"` - изменить размер изображения до 360 пикселей по высоте, а ширину подобрать автоматически по соотношению сторон. 
    -2 означает, что высота кадра должна быть кратна 2, это требование кодека H.264 - размеры должны быть обязательно четными числами. 
  * `-b:v:0 800k` - целевой битрейт видео
  * `-maxrate:0 856k` - максимальный допустимый битрейт видео
  * `-bufsize:0 1200k` - размер буфера кодировщика
  * Параметры битрейта видео подробнее описаны в [документации FFmpeg](https://trac.ffmpeg.org/wiki/Limiting%20the%20output%20bitrate).
* `-map 0:a` - использовать аудио №0 из входного файла
* `-init_seg_name "init\$RepresentationID\$.\$ext\$"` - шаблон имени файлов для сегментов инициализации DASH (файлы DASH будут описаны ниже).
  Здесь используются подстановки `\$RepresentationID\$` - номер аудио или видео потока, `\$ext\$` - расширение файла, в зависимости от выбранного контейнера.
* `-media_seg_name "chunk\$RepresentationID\$-\$Number%05d\$.\$ext\$"` - шаблон имени файла для сегментов с данными.
  Здесь также используются подстановки, в дополнение к предыдущим, `\$Number%05d\$` - номер сегмента, число из пяти цифр с ведущими нулями. 
* `-dash_segment_type mp4` - формат контейнера для сегментов, может быть `mp4` или `mpegts`
* `-use_template 1` - если указать 1, то использовать шаблон имени файла для описания всех сегментов в итоговом файле. 
  Если указать 0, то вместо шаблона имени будет перечисление имен всех сегментов.
* `-use_timeline 0` - если указать 1, то в дополнение к ожидаемой длительности сегмента перечислить фактическое время начала и длительность для каждого сегмента. 
  Используется для более точной навигации по файлу.
* `-seg_duration 10` - ожидаемая продолжительность одного сегмента (в секундах)
* `-adaptation_sets "id=0,streams=v id=1,streams=a"` - группировка потоков в итоговом файле (в данном случае группировка отдельно всех видео потоков и отдельно аудио поток)
* `-f dash` - использовать формат DASH
* `dash.mpd` - расположение итоговых файлов

В результате выполнения команды будет создано некоторое количество файлов (о них будет подробнее написано ниже).
Для воспроизведения результата можно воспользоваться таким html-кодом:

```html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link href="https://vjs.zencdn.net/7.10.2/video-js.css" rel="stylesheet" />
    <title>DASH</title>
</head>
<body>

<video id="my-video" class="video-js" controls preload="auto" width="640" height="264" data-setup="{}">
    <source src="dash.mpd" type="application/dash+xml" />
    <p class="vjs-no-js">NO SIGNAL</p>
</video>

<script src="https://vjs.zencdn.net/7.10.2/video.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/videojs-contrib-quality-levels@2.0.9/dist/videojs-contrib-quality-levels.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/videojs-hls-quality-selector@1.1.4/dist/videojs-hls-quality-selector.min.js"></script>
<script>
    const player = videojs('my-video');
    player.hlsQualitySelector();
</script>
</body>
</html>
```

Здесь используется плеер Video.js, который поддерживает формат DASH, с компонентом, позволяющим вручную выбирать качество видео.
По умолчанию качество видео будет подстраиваться автоматически. 

Таким образом решены все перечисленные ранее проблемы:

* Используется JavaScript-плеер, одинаково работающий в разных браузерах
* Файл разбивается на сегменты, поэтому нет необходимости скачивать его полностью - будет загружено только то, что в данный момент воспроизводится
* Видео и аудио перекодированы в формат, поддерживаемый большинством браузеров
* Качество видео автоматически подстраивается под скорость соединения

Недостатком такого подхода можно назвать необходимость перекодировать видео под каждый битрейт. 
Если файл большой, то это может потребовать большого количества времени и аппаратных ресурсов.
Чтобы разобраться, возможны ли другие подходы, рассмотрим файлы, которые создал FFmpeg.

## Файлы DASH

Здесь будет описываться только некоторая часть формата DASH для VOD (Video-on-Demand), для LIVE-трансляций файлы и описания могут быть другими. 
{: .alert .alert-info}

Формат DASH определяет три типа файлов:

* Файл описания (media presentation description, mpd)
* Сегменты инициализации
* Сегменты данных

Файл описания (dash.mpd), созданный FFmpeg с параметрами, описанными выше, будет выглядеть так:

```xml
<?xml version="1.0" encoding="utf-8"?>
<MPD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="urn:mpeg:dash:schema:mpd:2011"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 http://standards.iso.org/ittf/PubliclyAvailableStandards/MPEG-DASH_schema_files/DASH-MPD.xsd"
	profiles="urn:mpeg:dash:profile:isoff-live:2011"
	type="static"
	mediaPresentationDuration="PT1M30.0S"
	maxSegmentDuration="PT10.0S"
	minBufferTime="PT16.0S">
	<ProgramInformation>
	</ProgramInformation>
	<ServiceDescription id="0">
	</ServiceDescription>
	<Period id="0" start="PT0.0S">
		<AdaptationSet id="0" contentType="video" startWithSAP="1" segmentAlignment="true" bitstreamSwitching="true" 
                       frameRate="25/1" maxWidth="1920" maxHeight="1080" par="16:9" lang="und">
			<Representation id="0" mimeType="video/mp4" codecs="avc1.4d401e" 
                            bandwidth="800000" width="640" height="360" sar="1:1">
				<SegmentTemplate timescale="1000000" duration="10000000" 
                                 initialization="init$RepresentationID$.m4s" 
                                 media="chunk$RepresentationID$-$Number%05d$.m4s" 
                                 startNumber="1">
				</SegmentTemplate>
			</Representation>
			<Representation id="1" mimeType="video/mp4" codecs="avc1.4d401e" 
                            bandwidth="1400000" width="768" height="432" sar="1:1">
				<SegmentTemplate timescale="1000000" duration="10000000" 
                                 initialization="init$RepresentationID$.m4s" 
                                 media="chunk$RepresentationID$-$Number%05d$.m4s" 
                                 startNumber="1">
				</SegmentTemplate>
			</Representation>
			<Representation id="2" mimeType="video/mp4" codecs="avc1.4d401f" 
                            bandwidth="2000000" width="960" height="540" sar="1:1">
				<SegmentTemplate timescale="1000000" duration="10000000" 
                                 initialization="init$RepresentationID$.m4s" 
                                 media="chunk$RepresentationID$-$Number%05d$.m4s" 
                                 startNumber="1">
				</SegmentTemplate>
			</Representation>
			<Representation id="3" mimeType="video/mp4" codecs="avc1.4d401f" 
                            bandwidth="2800000" width="1280" height="720" sar="1:1">
				<SegmentTemplate timescale="1000000" duration="10000000" 
                                 initialization="init$RepresentationID$.m4s" 
                                 media="chunk$RepresentationID$-$Number%05d$.m4s" 
                                 startNumber="1">
				</SegmentTemplate>
			</Representation>
			<Representation id="4" mimeType="video/mp4" codecs="avc1.4d4028" 
                            bandwidth="5000000" width="1920" height="1080" sar="1:1">
				<SegmentTemplate timescale="1000000" duration="10000000" 
                                 initialization="init$RepresentationID$.m4s" 
                                 media="chunk$RepresentationID$-$Number%05d$.m4s" 
                                 startNumber="1">
				</SegmentTemplate>
			</Representation>
		</AdaptationSet>
		<AdaptationSet id="1" contentType="audio" startWithSAP="1" segmentAlignment="true" bitstreamSwitching="true" lang="und">
			<Representation id="5" mimeType="audio/mp4" codecs="mp4a.40.2" 
                            bandwidth="128000" audioSamplingRate="44100">
				<AudioChannelConfiguration schemeIdUri="urn:mpeg:dash:23003:3:audio_channel_configuration:2011" value="2" />
				<SegmentTemplate timescale="1000000" duration="10000000" 
                                 initialization="init$RepresentationID$.m4s" 
                                 media="chunk$RepresentationID$-$Number%05d$.m4s" 
                                 startNumber="1">
				</SegmentTemplate>
			</Representation>
		</AdaptationSet>
	</Period>
</MPD>
```

Это файл XML, в котором представлены основные параметры видео и аудио - общая продолжительность, количество потоков, форматы и имена файлов сегментов. 
В файле можно выделить такие сведения:

* `mediaPresentationDuration="PT1M30.0S"` - общая продолжительность видео
* `maxSegmentDuration="PT10.0S"` - ожидаемая длина сегмента (см. параметр `seg_duration` выше)
* `<AdaptationSet>` - группировка потоков аудио и видео. 
  В данном случае, в одной группе находятся потоки, полученные из перекодирования одного и того же исходного потока - например здесь сгруппированы видео с разным битрейтом.
  Аудио дорожка находится в отдельной группе и, если в исходном файле было бы несколько дорожек, то в mpd каждая находилась бы в своей группе.
  Также в AdaptationSet описывается тип потока и некоторые общие сведения (например для видео - соотношение сторон и частота кадров).
* `<Representation>` - описывает один поток.
  Здесь описывается тип потока, кодек, битрейт, для видео - размеры изображения, для аудио - частота дискретизации.
* `<SegmentTemplate>` - описывает, как хранятся файлы сегментов потока: 
  `id` - номер потока,
  `initialization` - шаблон имени сегмента инициализации (см. параметр `init_seg_name`), 
  `media` - шаблон имени файла с данными (см. параметр `media_seg_name`).

Файлы init0.m4s ... init5.m4s - это сегменты инициализации - они для каждого потока хранят информацию о кодеке (данных аудио и видео в них нет).
Сегменты инициализации скачиваются перед началом воспроизведения потока.

Файлы вида chunk0-00001.m4s - это сегменты с данными - они хранят данные для каждого потока. 
Формат этих файлов определяется выбранным типом контейнера (см. параметр `dash_segment_type`). 
В каждом файле хранится фрагмент видео или аудио длиной около `seg_duration` (в данном примере 10 секунд).
Эти файлы по отдельности могут не воспроизводиться обычными плеерами, т.к. они могут не содержать сведения о кодеке (которые находятся в сегменте инициализации). 

Проанализировав файлы и их содержимое можно предположить, что вместо многократного полного перекодирования исходного файла можно попробовать создавать нужные файлы по запросу.
Т.е. содержимое файла mpd и сегментов инициализации известно заранее, и их можно быстро сгенерировать.
А сегменты с данными можно попробовать получать перекодировав только часть исходного файла (длиной в один сегмент).
Этот подход будет описан в следующих разделах.

## Создание сегментов по запросу

TODO

## Ссылки

* [Video.js - JavaScript видео-плеер](https://videojs.com/)
* [FFmpeg](https://ffmpeg.org/)
* [HLS](https://en.wikipedia.org/wiki/HTTP_Live_Streaming)
* [DASH](https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP)  
* [Параметры FFmpeg для кодека H.264](https://trac.ffmpeg.org/wiki/Encode/H.264)
* [Параметры FFmpeg для кодека AAC](https://trac.ffmpeg.org/wiki/Encode/AAC)
* [Параметры FFmpeg для битрейта видео](https://trac.ffmpeg.org/wiki/Limiting%20the%20output%20bitrate)
* [Таблица рекомендованных значений битрейта видео и аудио](https://docs.peer5.com/guides/production-ready-hls-vod/#how-to-choose-the-right-bitrate)
* [Параметры FFmpeg для формата DASH](https://ffmpeg.org/ffmpeg-formats.html#dash-2)
